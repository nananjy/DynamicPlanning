# DynamicPlanning 动态规划
&emsp;&emsp;能用动态规划求解的题目，必须具有最优子结构和无后效性的特点。动态规划的程序只要状态转移方程相同，则写成下面两种形式的复杂度级别是相同的。
- 可以写成“递归函数 + 用数组记录计算结果”的形式
- 也可以写成不用递归，在数组内由已知推未知的递推形式。

**动态规划的实质是用空间换时间。**

**递归形式**
- 优点是直观好写（对已经习惯递归思维的程序员来说）。
- 缺点是
  1. 函数调用有开销，因此效率略低；
  2. 如果递归层数太深，也可能导致栈空间溢出，程序运行出错；
  3. 递归的写法无法使用滚动数组来节省空间。

**递推形式**
- 优点是
  1. 在时间上比递归写法效率略高；
  2. 可以使用**滚动数组**减少所需空间。
- 缺点是递推的顺序需仔细思考，否则容易写错。

递推写法有**人人为我**和**我为人人**两种思路（“滑雪计算最大滑坡”），前者用的更多。
* **人人为我**指用若干个值已知的状态的值，推算出一个值未知的状态的值。“人人”即值已知的状态，“我”即值未知的状态。
* **我为人人**指一旦一个状态X的值被求出，就查看X的这个新值会对哪些状态的值产生影响，更新那些可能受影响状态的值。“我”即状态X, “人人”即可能被X新值所影响的状态。

&emsp;&emsp;在用“人人为我”递推时，常常碰到要从若干个值已知的状态F1, F2, ..., Fn中寻找最优状态。此时，如果顺序逐个考察F1, F2, ..., Fn来选最优状态，可能导致时间复杂度过大，考虑使用**优先队列**等数据结构，使选优过程加快，如“灌溉草场”问题。

&emsp;&emsp;特别注意，如果设计的状态（子问题）构造不出状态转移方程，或即便能构造出状态转移方程，但在两个状态之间转移（递推）时，效率过低，则应该考虑将状态描述细化，即为代表状态的函数（递归写法）增加一个参数，为记录状态值的数组增加一个维度。这样在新的状态下，就容易构造出效率可接受的状态转移方程。如“方盒有戏，消除方盒”和“美妙栅栏，获取栅栏中木棒长度”。
